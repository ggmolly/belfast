// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: builds.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBuild = `-- name: CreateBuild :one

INSERT INTO builds (
  builder_id,
  ship_id,
  pool_id,
  finishes_at
) VALUES (
  $1, $2, $3, $4
)
RETURNING id
`

type CreateBuildParams struct {
	BuilderID  int64
	ShipID     int64
	PoolID     int64
	FinishesAt pgtype.Timestamptz
}

// Build queue queries
func (q *Queries) CreateBuild(ctx context.Context, arg CreateBuildParams) (int64, error) {
	row := q.db.QueryRow(ctx, createBuild,
		arg.BuilderID,
		arg.ShipID,
		arg.PoolID,
		arg.FinishesAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteBuildByID = `-- name: DeleteBuildByID :execresult
DELETE FROM builds
WHERE id = $1
`

func (q *Queries) DeleteBuildByID(ctx context.Context, id int64) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteBuildByID, id)
}

const getBuildByID = `-- name: GetBuildByID :one
SELECT id, builder_id, ship_id, pool_id, finishes_at
FROM builds
WHERE id = $1
`

func (q *Queries) GetBuildByID(ctx context.Context, id int64) (Build, error) {
	row := q.db.QueryRow(ctx, getBuildByID, id)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.BuilderID,
		&i.ShipID,
		&i.PoolID,
		&i.FinishesAt,
	)
	return i, err
}

const listBuildsRangeByBuilderID = `-- name: ListBuildsRangeByBuilderID :many
SELECT id, builder_id, ship_id, pool_id, finishes_at
FROM builds
WHERE builder_id = $1
ORDER BY id ASC
OFFSET $2
LIMIT $3
`

type ListBuildsRangeByBuilderIDParams struct {
	BuilderID int64
	Offset    int32
	Limit     int32
}

func (q *Queries) ListBuildsRangeByBuilderID(ctx context.Context, arg ListBuildsRangeByBuilderIDParams) ([]Build, error) {
	rows, err := q.db.Query(ctx, listBuildsRangeByBuilderID, arg.BuilderID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Build
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.BuilderID,
			&i.ShipID,
			&i.PoolID,
			&i.FinishesAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBuild = `-- name: UpdateBuild :exec
UPDATE builds
SET builder_id = $2,
    ship_id = $3,
    pool_id = $4,
    finishes_at = $5
WHERE id = $1
`

type UpdateBuildParams struct {
	ID         int64
	BuilderID  int64
	ShipID     int64
	PoolID     int64
	FinishesAt pgtype.Timestamptz
}

func (q *Queries) UpdateBuild(ctx context.Context, arg UpdateBuildParams) error {
	_, err := q.db.Exec(ctx, updateBuild,
		arg.ID,
		arg.BuilderID,
		arg.ShipID,
		arg.PoolID,
		arg.FinishesAt,
	)
	return err
}
