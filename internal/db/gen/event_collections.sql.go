// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: event_collections.sql

package gen

import (
	"context"
)

const countActiveEventCollections = `-- name: CountActiveEventCollections :one
SELECT COUNT(*)::bigint
FROM event_collections
WHERE commander_id = $1
  AND finish_time > 0
`

func (q *Queries) CountActiveEventCollections(ctx context.Context, commanderID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveEventCollections, commanderID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createEventCollection = `-- name: CreateEventCollection :exec
INSERT INTO event_collections (
  commander_id,
  collection_id,
  start_time,
  finish_time,
  ship_ids
) VALUES (
  $1, $2, $3, $4, $5
)
ON CONFLICT DO NOTHING
`

type CreateEventCollectionParams struct {
	CommanderID  int64
	CollectionID int64
	StartTime    int64
	FinishTime   int64
	ShipIds      []byte
}

func (q *Queries) CreateEventCollection(ctx context.Context, arg CreateEventCollectionParams) error {
	_, err := q.db.Exec(ctx, createEventCollection,
		arg.CommanderID,
		arg.CollectionID,
		arg.StartTime,
		arg.FinishTime,
		arg.ShipIds,
	)
	return err
}

const deleteEventCollection = `-- name: DeleteEventCollection :exec
DELETE FROM event_collections
WHERE commander_id = $1
  AND collection_id = $2
`

type DeleteEventCollectionParams struct {
	CommanderID  int64
	CollectionID int64
}

func (q *Queries) DeleteEventCollection(ctx context.Context, arg DeleteEventCollectionParams) error {
	_, err := q.db.Exec(ctx, deleteEventCollection, arg.CommanderID, arg.CollectionID)
	return err
}

const getEventCollection = `-- name: GetEventCollection :one

SELECT commander_id, collection_id, start_time, finish_time, ship_ids
FROM event_collections
WHERE commander_id = $1
  AND collection_id = $2
`

type GetEventCollectionParams struct {
	CommanderID  int64
	CollectionID int64
}

// Event collection queries
func (q *Queries) GetEventCollection(ctx context.Context, arg GetEventCollectionParams) (EventCollection, error) {
	row := q.db.QueryRow(ctx, getEventCollection, arg.CommanderID, arg.CollectionID)
	var i EventCollection
	err := row.Scan(
		&i.CommanderID,
		&i.CollectionID,
		&i.StartTime,
		&i.FinishTime,
		&i.ShipIds,
	)
	return i, err
}

const listBusyEventCollections = `-- name: ListBusyEventCollections :many
SELECT commander_id, collection_id, start_time, finish_time, ship_ids
FROM event_collections
WHERE commander_id = $1
  AND finish_time > 0
`

func (q *Queries) ListBusyEventCollections(ctx context.Context, commanderID int64) ([]EventCollection, error) {
	rows, err := q.db.Query(ctx, listBusyEventCollections, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventCollection
	for rows.Next() {
		var i EventCollection
		if err := rows.Scan(
			&i.CommanderID,
			&i.CollectionID,
			&i.StartTime,
			&i.FinishTime,
			&i.ShipIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventCollection = `-- name: UpdateEventCollection :exec
UPDATE event_collections
SET start_time = $3,
    finish_time = $4,
    ship_ids = $5
WHERE commander_id = $1
  AND collection_id = $2
`

type UpdateEventCollectionParams struct {
	CommanderID  int64
	CollectionID int64
	StartTime    int64
	FinishTime   int64
	ShipIds      []byte
}

func (q *Queries) UpdateEventCollection(ctx context.Context, arg UpdateEventCollectionParams) error {
	_, err := q.db.Exec(ctx, updateEventCollection,
		arg.CommanderID,
		arg.CollectionID,
		arg.StartTime,
		arg.FinishTime,
		arg.ShipIds,
	)
	return err
}
