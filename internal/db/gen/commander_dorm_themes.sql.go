// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: commander_dorm_themes.sql

package gen

import (
	"context"
)

const deleteCommanderDormTheme = `-- name: DeleteCommanderDormTheme :exec
DELETE FROM commander_dorm_themes
WHERE commander_id = $1
  AND theme_slot_id = $2
`

type DeleteCommanderDormThemeParams struct {
	CommanderID int64
	ThemeSlotID int64
}

func (q *Queries) DeleteCommanderDormTheme(ctx context.Context, arg DeleteCommanderDormThemeParams) error {
	_, err := q.db.Exec(ctx, deleteCommanderDormTheme, arg.CommanderID, arg.ThemeSlotID)
	return err
}

const getCommanderDormTheme = `-- name: GetCommanderDormTheme :one
SELECT commander_id, theme_slot_id, name, furniture_put_list
FROM commander_dorm_themes
WHERE commander_id = $1
  AND theme_slot_id = $2
`

type GetCommanderDormThemeParams struct {
	CommanderID int64
	ThemeSlotID int64
}

func (q *Queries) GetCommanderDormTheme(ctx context.Context, arg GetCommanderDormThemeParams) (CommanderDormTheme, error) {
	row := q.db.QueryRow(ctx, getCommanderDormTheme, arg.CommanderID, arg.ThemeSlotID)
	var i CommanderDormTheme
	err := row.Scan(
		&i.CommanderID,
		&i.ThemeSlotID,
		&i.Name,
		&i.FurniturePutList,
	)
	return i, err
}

const listCommanderDormThemes = `-- name: ListCommanderDormThemes :many
SELECT commander_id, theme_slot_id, name, furniture_put_list
FROM commander_dorm_themes
WHERE commander_id = $1
ORDER BY theme_slot_id ASC
`

func (q *Queries) ListCommanderDormThemes(ctx context.Context, commanderID int64) ([]CommanderDormTheme, error) {
	rows, err := q.db.Query(ctx, listCommanderDormThemes, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommanderDormTheme
	for rows.Next() {
		var i CommanderDormTheme
		if err := rows.Scan(
			&i.CommanderID,
			&i.ThemeSlotID,
			&i.Name,
			&i.FurniturePutList,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCommanderDormTheme = `-- name: UpsertCommanderDormTheme :exec

INSERT INTO commander_dorm_themes (
  commander_id,
  theme_slot_id,
  name,
  furniture_put_list
) VALUES (
  $1, $2, $3, $4
)
ON CONFLICT (commander_id, theme_slot_id)
DO UPDATE SET
  name = EXCLUDED.name,
  furniture_put_list = EXCLUDED.furniture_put_list
`

type UpsertCommanderDormThemeParams struct {
	CommanderID      int64
	ThemeSlotID      int64
	Name             string
	FurniturePutList []byte
}

// Commander dorm theme queries
func (q *Queries) UpsertCommanderDormTheme(ctx context.Context, arg UpsertCommanderDormThemeParams) error {
	_, err := q.db.Exec(ctx, upsertCommanderDormTheme,
		arg.CommanderID,
		arg.ThemeSlotID,
		arg.Name,
		arg.FurniturePutList,
	)
	return err
}
