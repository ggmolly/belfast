// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: sessions.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  id,
  account_id,
  created_at,
  last_seen_at,
  expires_at,
  ip_address,
  user_agent,
  revoked_at,
  csrf_token,
  csrf_expires_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING
  id,
  account_id,
  created_at,
  last_seen_at,
  expires_at,
  ip_address,
  user_agent,
  revoked_at,
  csrf_token,
  csrf_expires_at
`

type CreateSessionParams struct {
	ID            string
	AccountID     string
	CreatedAt     pgtype.Timestamptz
	LastSeenAt    pgtype.Timestamptz
	ExpiresAt     pgtype.Timestamptz
	IpAddress     string
	UserAgent     string
	RevokedAt     pgtype.Timestamptz
	CsrfToken     string
	CsrfExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.AccountID,
		arg.CreatedAt,
		arg.LastSeenAt,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
		arg.RevokedAt,
		arg.CsrfToken,
		arg.CsrfExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.RevokedAt,
		&i.CsrfToken,
		&i.CsrfExpiresAt,
	)
	return i, err
}

const getSessionByIDActive = `-- name: GetSessionByIDActive :one
SELECT
  id,
  account_id,
  created_at,
  last_seen_at,
  expires_at,
  ip_address,
  user_agent,
  revoked_at,
  csrf_token,
  csrf_expires_at
FROM sessions
WHERE id = $1
  AND revoked_at IS NULL
`

func (q *Queries) GetSessionByIDActive(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByIDActive, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.RevokedAt,
		&i.CsrfToken,
		&i.CsrfExpiresAt,
	)
	return i, err
}

const refreshSessionCSRF = `-- name: RefreshSessionCSRF :exec
UPDATE sessions
SET csrf_token = $2,
    csrf_expires_at = $3
WHERE id = $1
`

type RefreshSessionCSRFParams struct {
	ID            string
	CsrfToken     string
	CsrfExpiresAt pgtype.Timestamptz
}

func (q *Queries) RefreshSessionCSRF(ctx context.Context, arg RefreshSessionCSRFParams) error {
	_, err := q.db.Exec(ctx, refreshSessionCSRF, arg.ID, arg.CsrfToken, arg.CsrfExpiresAt)
	return err
}

const revokeSession = `-- name: RevokeSession :exec
UPDATE sessions
SET revoked_at = $2
WHERE id = $1
`

type RevokeSessionParams struct {
	ID        string
	RevokedAt pgtype.Timestamptz
}

func (q *Queries) RevokeSession(ctx context.Context, arg RevokeSessionParams) error {
	_, err := q.db.Exec(ctx, revokeSession, arg.ID, arg.RevokedAt)
	return err
}

const revokeSessionsAll = `-- name: RevokeSessionsAll :exec
UPDATE sessions
SET revoked_at = $2
WHERE account_id = $1
  AND revoked_at IS NULL
`

type RevokeSessionsAllParams struct {
	AccountID string
	RevokedAt pgtype.Timestamptz
}

func (q *Queries) RevokeSessionsAll(ctx context.Context, arg RevokeSessionsAllParams) error {
	_, err := q.db.Exec(ctx, revokeSessionsAll, arg.AccountID, arg.RevokedAt)
	return err
}

const revokeSessionsExcept = `-- name: RevokeSessionsExcept :exec
UPDATE sessions
SET revoked_at = $3
WHERE account_id = $1
  AND revoked_at IS NULL
  AND id <> $2
`

type RevokeSessionsExceptParams struct {
	AccountID string
	ID        string
	RevokedAt pgtype.Timestamptz
}

func (q *Queries) RevokeSessionsExcept(ctx context.Context, arg RevokeSessionsExceptParams) error {
	_, err := q.db.Exec(ctx, revokeSessionsExcept, arg.AccountID, arg.ID, arg.RevokedAt)
	return err
}

const touchSession = `-- name: TouchSession :exec
UPDATE sessions
SET last_seen_at = $2
WHERE id = $1
`

type TouchSessionParams struct {
	ID         string
	LastSeenAt pgtype.Timestamptz
}

func (q *Queries) TouchSession(ctx context.Context, arg TouchSessionParams) error {
	_, err := q.db.Exec(ctx, touchSession, arg.ID, arg.LastSeenAt)
	return err
}

const touchSessionWithExpires = `-- name: TouchSessionWithExpires :exec
UPDATE sessions
SET last_seen_at = $2,
    expires_at = $3
WHERE id = $1
`

type TouchSessionWithExpiresParams struct {
	ID         string
	LastSeenAt pgtype.Timestamptz
	ExpiresAt  pgtype.Timestamptz
}

func (q *Queries) TouchSessionWithExpires(ctx context.Context, arg TouchSessionWithExpiresParams) error {
	_, err := q.db.Exec(ctx, touchSessionWithExpires, arg.ID, arg.LastSeenAt, arg.ExpiresAt)
	return err
}
