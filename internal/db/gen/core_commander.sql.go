// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: core_commander.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCommandersByName = `-- name: CountCommandersByName :one
SELECT COUNT(*)::bigint
FROM commanders
WHERE name = $1
  AND deleted_at IS NULL
`

func (q *Queries) CountCommandersByName(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRow(ctx, countCommandersByName, name)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createCommander = `-- name: CreateCommander :exec

INSERT INTO commanders (
  commander_id,
  account_id,
  level,
  exp,
  name,
  last_login,
  guide_index,
  new_guide_index,
  name_change_cooldown,
  room_id,
  exchange_count,
  draw_count1,
  draw_count10,
  support_requisition_count,
  support_requisition_month,
  collect_attack_count,
  acc_pay_lv,
  living_area_cover_id,
  selected_icon_frame_id,
  selected_chat_frame_id,
  selected_battle_ui_id,
  display_icon_id,
  display_skin_id,
  display_icon_theme_id,
  manifesto,
  dorm_name,
  random_ship_mode,
  random_flag_ship_enabled
) VALUES (
  $1, $2, 1, 0, $3, now(), $4, $5, '1970-01-01 00:00:00+00',
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, false
)
`

type CreateCommanderParams struct {
	CommanderID   int64
	AccountID     int64
	Name          string
	GuideIndex    int64
	NewGuideIndex int64
}

// Commander aggregate load queries (Milestone 4)
func (q *Queries) CreateCommander(ctx context.Context, arg CreateCommanderParams) error {
	_, err := q.db.Exec(ctx, createCommander,
		arg.CommanderID,
		arg.AccountID,
		arg.Name,
		arg.GuideIndex,
		arg.NewGuideIndex,
	)
	return err
}

const getCommanderByAccountID = `-- name: GetCommanderByAccountID :one
SELECT
  commander_id,
  account_id,
  level,
  exp,
  name,
  last_login,
  guide_index,
  new_guide_index,
  name_change_cooldown,
  room_id,
  exchange_count,
  draw_count1,
  draw_count10,
  support_requisition_count,
  support_requisition_month,
  collect_attack_count,
  acc_pay_lv,
  living_area_cover_id,
  selected_icon_frame_id,
  selected_chat_frame_id,
  selected_battle_ui_id,
  display_icon_id,
  display_skin_id,
  display_icon_theme_id,
  manifesto,
  dorm_name,
  random_ship_mode,
  random_flag_ship_enabled
FROM commanders
WHERE account_id = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetCommanderByAccountIDRow struct {
	CommanderID             int64
	AccountID               int64
	Level                   int32
	Exp                     int32
	Name                    string
	LastLogin               pgtype.Timestamptz
	GuideIndex              int64
	NewGuideIndex           int64
	NameChangeCooldown      pgtype.Timestamptz
	RoomID                  int64
	ExchangeCount           int64
	DrawCount1              int64
	DrawCount10             int64
	SupportRequisitionCount int64
	SupportRequisitionMonth int64
	CollectAttackCount      int64
	AccPayLv                int64
	LivingAreaCoverID       int64
	SelectedIconFrameID     int64
	SelectedChatFrameID     int64
	SelectedBattleUiID      int64
	DisplayIconID           int64
	DisplaySkinID           int64
	DisplayIconThemeID      int64
	Manifesto               string
	DormName                string
	RandomShipMode          int64
	RandomFlagShipEnabled   bool
}

func (q *Queries) GetCommanderByAccountID(ctx context.Context, accountID int64) (GetCommanderByAccountIDRow, error) {
	row := q.db.QueryRow(ctx, getCommanderByAccountID, accountID)
	var i GetCommanderByAccountIDRow
	err := row.Scan(
		&i.CommanderID,
		&i.AccountID,
		&i.Level,
		&i.Exp,
		&i.Name,
		&i.LastLogin,
		&i.GuideIndex,
		&i.NewGuideIndex,
		&i.NameChangeCooldown,
		&i.RoomID,
		&i.ExchangeCount,
		&i.DrawCount1,
		&i.DrawCount10,
		&i.SupportRequisitionCount,
		&i.SupportRequisitionMonth,
		&i.CollectAttackCount,
		&i.AccPayLv,
		&i.LivingAreaCoverID,
		&i.SelectedIconFrameID,
		&i.SelectedChatFrameID,
		&i.SelectedBattleUiID,
		&i.DisplayIconID,
		&i.DisplaySkinID,
		&i.DisplayIconThemeID,
		&i.Manifesto,
		&i.DormName,
		&i.RandomShipMode,
		&i.RandomFlagShipEnabled,
	)
	return i, err
}

const getCommanderByID = `-- name: GetCommanderByID :one
SELECT
  commander_id,
  account_id,
  level,
  exp,
  name,
  last_login,
  guide_index,
  new_guide_index,
  name_change_cooldown,
  room_id,
  exchange_count,
  draw_count1,
  draw_count10,
  support_requisition_count,
  support_requisition_month,
  collect_attack_count,
  acc_pay_lv,
  living_area_cover_id,
  selected_icon_frame_id,
  selected_chat_frame_id,
  selected_battle_ui_id,
  display_icon_id,
  display_skin_id,
  display_icon_theme_id,
  manifesto,
  dorm_name,
  random_ship_mode,
  random_flag_ship_enabled
FROM commanders
WHERE commander_id = $1
  AND deleted_at IS NULL
`

type GetCommanderByIDRow struct {
	CommanderID             int64
	AccountID               int64
	Level                   int32
	Exp                     int32
	Name                    string
	LastLogin               pgtype.Timestamptz
	GuideIndex              int64
	NewGuideIndex           int64
	NameChangeCooldown      pgtype.Timestamptz
	RoomID                  int64
	ExchangeCount           int64
	DrawCount1              int64
	DrawCount10             int64
	SupportRequisitionCount int64
	SupportRequisitionMonth int64
	CollectAttackCount      int64
	AccPayLv                int64
	LivingAreaCoverID       int64
	SelectedIconFrameID     int64
	SelectedChatFrameID     int64
	SelectedBattleUiID      int64
	DisplayIconID           int64
	DisplaySkinID           int64
	DisplayIconThemeID      int64
	Manifesto               string
	DormName                string
	RandomShipMode          int64
	RandomFlagShipEnabled   bool
}

func (q *Queries) GetCommanderByID(ctx context.Context, commanderID int64) (GetCommanderByIDRow, error) {
	row := q.db.QueryRow(ctx, getCommanderByID, commanderID)
	var i GetCommanderByIDRow
	err := row.Scan(
		&i.CommanderID,
		&i.AccountID,
		&i.Level,
		&i.Exp,
		&i.Name,
		&i.LastLogin,
		&i.GuideIndex,
		&i.NewGuideIndex,
		&i.NameChangeCooldown,
		&i.RoomID,
		&i.ExchangeCount,
		&i.DrawCount1,
		&i.DrawCount10,
		&i.SupportRequisitionCount,
		&i.SupportRequisitionMonth,
		&i.CollectAttackCount,
		&i.AccPayLv,
		&i.LivingAreaCoverID,
		&i.SelectedIconFrameID,
		&i.SelectedChatFrameID,
		&i.SelectedBattleUiID,
		&i.DisplayIconID,
		&i.DisplaySkinID,
		&i.DisplayIconThemeID,
		&i.Manifesto,
		&i.DormName,
		&i.RandomShipMode,
		&i.RandomFlagShipEnabled,
	)
	return i, err
}

const listBuildsWithShipByBuilderID = `-- name: ListBuildsWithShipByBuilderID :many
SELECT
  b.id,
  b.builder_id,
  b.ship_id,
  b.pool_id,
  b.finishes_at,
  s.template_id AS ship_template_id,
  s.name AS ship_name,
  s.english_name AS ship_english_name,
  s.rarity_id AS ship_rarity_id,
  s.star AS ship_star,
  s.type AS ship_type,
  s.nationality AS ship_nationality,
  s.build_time AS ship_build_time,
  s.pool_id AS ship_pool_id
FROM builds AS b
JOIN ships AS s ON s.template_id = b.ship_id
WHERE b.builder_id = $1
ORDER BY b.id ASC
`

type ListBuildsWithShipByBuilderIDRow struct {
	ID              int64
	BuilderID       int64
	ShipID          int64
	PoolID          int64
	FinishesAt      pgtype.Timestamptz
	ShipTemplateID  int64
	ShipName        string
	ShipEnglishName string
	ShipRarityID    int64
	ShipStar        int64
	ShipType        int64
	ShipNationality int64
	ShipBuildTime   int64
	ShipPoolID      pgtype.Int8
}

func (q *Queries) ListBuildsWithShipByBuilderID(ctx context.Context, builderID int64) ([]ListBuildsWithShipByBuilderIDRow, error) {
	rows, err := q.db.Query(ctx, listBuildsWithShipByBuilderID, builderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBuildsWithShipByBuilderIDRow
	for rows.Next() {
		var i ListBuildsWithShipByBuilderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.BuilderID,
			&i.ShipID,
			&i.PoolID,
			&i.FinishesAt,
			&i.ShipTemplateID,
			&i.ShipName,
			&i.ShipEnglishName,
			&i.ShipRarityID,
			&i.ShipStar,
			&i.ShipType,
			&i.ShipNationality,
			&i.ShipBuildTime,
			&i.ShipPoolID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommanderItemsWithItemByCommanderID = `-- name: ListCommanderItemsWithItemByCommanderID :many
SELECT
  ci.commander_id,
  ci.item_id,
  ci.count,
  i.id AS item_id_full,
  i.name AS item_name,
  i.rarity AS item_rarity,
  i.shop_id AS item_shop_id,
  i.type AS item_type,
  i.virtual_type AS item_virtual_type
FROM commander_items AS ci
JOIN items AS i ON i.id = ci.item_id
WHERE ci.commander_id = $1
ORDER BY ci.item_id ASC
`

type ListCommanderItemsWithItemByCommanderIDRow struct {
	CommanderID     int64
	ItemID          int64
	Count           int64
	ItemIDFull      int64
	ItemName        string
	ItemRarity      int32
	ItemShopID      int32
	ItemType        int32
	ItemVirtualType int32
}

func (q *Queries) ListCommanderItemsWithItemByCommanderID(ctx context.Context, commanderID int64) ([]ListCommanderItemsWithItemByCommanderIDRow, error) {
	rows, err := q.db.Query(ctx, listCommanderItemsWithItemByCommanderID, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCommanderItemsWithItemByCommanderIDRow
	for rows.Next() {
		var i ListCommanderItemsWithItemByCommanderIDRow
		if err := rows.Scan(
			&i.CommanderID,
			&i.ItemID,
			&i.Count,
			&i.ItemIDFull,
			&i.ItemName,
			&i.ItemRarity,
			&i.ItemShopID,
			&i.ItemType,
			&i.ItemVirtualType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommanderMiscItemsWithItemByCommanderID = `-- name: ListCommanderMiscItemsWithItemByCommanderID :many
SELECT
  cmi.commander_id,
  cmi.item_id,
  cmi.data,
  i.id AS item_id_full,
  i.name AS item_name,
  i.rarity AS item_rarity,
  i.shop_id AS item_shop_id,
  i.type AS item_type,
  i.virtual_type AS item_virtual_type
FROM commander_misc_items AS cmi
JOIN items AS i ON i.id = cmi.item_id
WHERE cmi.commander_id = $1
ORDER BY cmi.item_id ASC
`

type ListCommanderMiscItemsWithItemByCommanderIDRow struct {
	CommanderID     int64
	ItemID          int64
	Data            int64
	ItemIDFull      int64
	ItemName        string
	ItemRarity      int32
	ItemShopID      int32
	ItemType        int32
	ItemVirtualType int32
}

func (q *Queries) ListCommanderMiscItemsWithItemByCommanderID(ctx context.Context, commanderID int64) ([]ListCommanderMiscItemsWithItemByCommanderIDRow, error) {
	rows, err := q.db.Query(ctx, listCommanderMiscItemsWithItemByCommanderID, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCommanderMiscItemsWithItemByCommanderIDRow
	for rows.Next() {
		var i ListCommanderMiscItemsWithItemByCommanderIDRow
		if err := rows.Scan(
			&i.CommanderID,
			&i.ItemID,
			&i.Data,
			&i.ItemIDFull,
			&i.ItemName,
			&i.ItemRarity,
			&i.ItemShopID,
			&i.ItemType,
			&i.ItemVirtualType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFleetsByCommanderID = `-- name: ListFleetsByCommanderID :many
SELECT
  id,
  game_id,
  commander_id,
  name,
  ship_list,
  meowfficer_list
FROM fleets
WHERE commander_id = $1
ORDER BY game_id ASC
`

func (q *Queries) ListFleetsByCommanderID(ctx context.Context, commanderID int64) ([]Fleet, error) {
	rows, err := q.db.Query(ctx, listFleetsByCommanderID, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Fleet
	for rows.Next() {
		var i Fleet
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.CommanderID,
			&i.Name,
			&i.ShipList,
			&i.MeowfficerList,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailAttachmentsByMailIDs = `-- name: ListMailAttachmentsByMailIDs :many
SELECT
  id,
  mail_id,
  type,
  item_id,
  quantity
FROM mail_attachments
WHERE mail_id = ANY($1::bigint[])
ORDER BY mail_id ASC, id ASC
`

func (q *Queries) ListMailAttachmentsByMailIDs(ctx context.Context, dollar_1 []int64) ([]MailAttachment, error) {
	rows, err := q.db.Query(ctx, listMailAttachmentsByMailIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MailAttachment
	for rows.Next() {
		var i MailAttachment
		if err := rows.Scan(
			&i.ID,
			&i.MailID,
			&i.Type,
			&i.ItemID,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailsByReceiverID = `-- name: ListMailsByReceiverID :many
SELECT
  id,
  receiver_id,
  read,
  date,
  title,
  body,
  attachments_collected,
  is_important,
  custom_sender,
  is_archived,
  created_at
FROM mails
WHERE receiver_id = $1
ORDER BY id ASC
`

func (q *Queries) ListMailsByReceiverID(ctx context.Context, receiverID int64) ([]Mail, error) {
	rows, err := q.db.Query(ctx, listMailsByReceiverID, receiverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Mail
	for rows.Next() {
		var i Mail
		if err := rows.Scan(
			&i.ID,
			&i.ReceiverID,
			&i.Read,
			&i.Date,
			&i.Title,
			&i.Body,
			&i.AttachmentsCollected,
			&i.IsImportant,
			&i.CustomSender,
			&i.IsArchived,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOwnedEquipmentsByCommanderID = `-- name: ListOwnedEquipmentsByCommanderID :many
SELECT
  commander_id,
  equipment_id,
  count
FROM owned_equipments
WHERE commander_id = $1
ORDER BY equipment_id ASC
`

func (q *Queries) ListOwnedEquipmentsByCommanderID(ctx context.Context, commanderID int64) ([]OwnedEquipment, error) {
	rows, err := q.db.Query(ctx, listOwnedEquipmentsByCommanderID, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OwnedEquipment
	for rows.Next() {
		var i OwnedEquipment
		if err := rows.Scan(&i.CommanderID, &i.EquipmentID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOwnedResourcesWithResourceByCommanderID = `-- name: ListOwnedResourcesWithResourceByCommanderID :many
SELECT
  o.commander_id,
  o.resource_id,
  o.amount,
  r.id AS resource_id_full,
  r.item_id AS resource_item_id,
  r.name AS resource_name
FROM owned_resources AS o
JOIN resources AS r ON r.id = o.resource_id
WHERE o.commander_id = $1
ORDER BY o.resource_id ASC
`

type ListOwnedResourcesWithResourceByCommanderIDRow struct {
	CommanderID    int64
	ResourceID     int64
	Amount         int64
	ResourceIDFull int64
	ResourceItemID int64
	ResourceName   string
}

func (q *Queries) ListOwnedResourcesWithResourceByCommanderID(ctx context.Context, commanderID int64) ([]ListOwnedResourcesWithResourceByCommanderIDRow, error) {
	rows, err := q.db.Query(ctx, listOwnedResourcesWithResourceByCommanderID, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOwnedResourcesWithResourceByCommanderIDRow
	for rows.Next() {
		var i ListOwnedResourcesWithResourceByCommanderIDRow
		if err := rows.Scan(
			&i.CommanderID,
			&i.ResourceID,
			&i.Amount,
			&i.ResourceIDFull,
			&i.ResourceItemID,
			&i.ResourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOwnedShipEquipmentsByOwnerID = `-- name: ListOwnedShipEquipmentsByOwnerID :many
SELECT
  owner_id,
  ship_id,
  pos,
  equip_id,
  skin_id
FROM owned_ship_equipments
WHERE owner_id = $1
ORDER BY ship_id ASC, pos ASC
`

func (q *Queries) ListOwnedShipEquipmentsByOwnerID(ctx context.Context, ownerID int64) ([]OwnedShipEquipment, error) {
	rows, err := q.db.Query(ctx, listOwnedShipEquipmentsByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OwnedShipEquipment
	for rows.Next() {
		var i OwnedShipEquipment
		if err := rows.Scan(
			&i.OwnerID,
			&i.ShipID,
			&i.Pos,
			&i.EquipID,
			&i.SkinID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOwnedShipStrengthsByOwnerID = `-- name: ListOwnedShipStrengthsByOwnerID :many
SELECT
  owner_id,
  ship_id,
  strength_id,
  exp
FROM owned_ship_strengths
WHERE owner_id = $1
ORDER BY ship_id ASC, strength_id ASC
`

func (q *Queries) ListOwnedShipStrengthsByOwnerID(ctx context.Context, ownerID int64) ([]OwnedShipStrength, error) {
	rows, err := q.db.Query(ctx, listOwnedShipStrengthsByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OwnedShipStrength
	for rows.Next() {
		var i OwnedShipStrength
		if err := rows.Scan(
			&i.OwnerID,
			&i.ShipID,
			&i.StrengthID,
			&i.Exp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOwnedShipsWithShipByOwnerID = `-- name: ListOwnedShipsWithShipByOwnerID :many
SELECT
  os.owner_id,
  os.ship_id,
  os.id,
  os.level,
  os.exp,
  os.surplus_exp,
  os.max_level,
  os.intimacy,
  os.is_locked,
  os.propose,
  os.common_flag,
  os.blueprint_flag,
  os.proficiency,
  os.activity_npc,
  os.custom_name,
  os.change_name_timestamp,
  os.create_time,
  os.energy,
  os.state,
  os.state_info1,
  os.state_info2,
  os.state_info3,
  os.state_info4,
  os.skin_id,
  os.is_secretary,
  os.secretary_position,
  os.secretary_phantom_id,
  s.template_id AS ship_template_id,
  s.name AS ship_name,
  s.english_name AS ship_english_name,
  s.rarity_id AS ship_rarity_id,
  s.star AS ship_star,
  s.type AS ship_type,
  s.nationality AS ship_nationality,
  s.build_time AS ship_build_time,
  s.pool_id AS ship_pool_id
FROM owned_ships AS os
JOIN ships AS s ON s.template_id = os.ship_id
WHERE os.owner_id = $1
  AND os.deleted_at IS NULL
ORDER BY os.id ASC
`

type ListOwnedShipsWithShipByOwnerIDRow struct {
	OwnerID             int64
	ShipID              int64
	ID                  int64
	Level               int64
	Exp                 int64
	SurplusExp          int64
	MaxLevel            int64
	Intimacy            int64
	IsLocked            bool
	Propose             bool
	CommonFlag          bool
	BlueprintFlag       bool
	Proficiency         bool
	ActivityNpc         int64
	CustomName          string
	ChangeNameTimestamp pgtype.Timestamptz
	CreateTime          pgtype.Timestamptz
	Energy              int64
	State               int64
	StateInfo1          int64
	StateInfo2          int64
	StateInfo3          int64
	StateInfo4          int64
	SkinID              int64
	IsSecretary         bool
	SecretaryPosition   pgtype.Int8
	SecretaryPhantomID  int64
	ShipTemplateID      int64
	ShipName            string
	ShipEnglishName     string
	ShipRarityID        int64
	ShipStar            int64
	ShipType            int64
	ShipNationality     int64
	ShipBuildTime       int64
	ShipPoolID          pgtype.Int8
}

func (q *Queries) ListOwnedShipsWithShipByOwnerID(ctx context.Context, ownerID int64) ([]ListOwnedShipsWithShipByOwnerIDRow, error) {
	rows, err := q.db.Query(ctx, listOwnedShipsWithShipByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOwnedShipsWithShipByOwnerIDRow
	for rows.Next() {
		var i ListOwnedShipsWithShipByOwnerIDRow
		if err := rows.Scan(
			&i.OwnerID,
			&i.ShipID,
			&i.ID,
			&i.Level,
			&i.Exp,
			&i.SurplusExp,
			&i.MaxLevel,
			&i.Intimacy,
			&i.IsLocked,
			&i.Propose,
			&i.CommonFlag,
			&i.BlueprintFlag,
			&i.Proficiency,
			&i.ActivityNpc,
			&i.CustomName,
			&i.ChangeNameTimestamp,
			&i.CreateTime,
			&i.Energy,
			&i.State,
			&i.StateInfo1,
			&i.StateInfo2,
			&i.StateInfo3,
			&i.StateInfo4,
			&i.SkinID,
			&i.IsSecretary,
			&i.SecretaryPosition,
			&i.SecretaryPhantomID,
			&i.ShipTemplateID,
			&i.ShipName,
			&i.ShipEnglishName,
			&i.ShipRarityID,
			&i.ShipStar,
			&i.ShipType,
			&i.ShipNationality,
			&i.ShipBuildTime,
			&i.ShipPoolID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOwnedSkinsByCommanderID = `-- name: ListOwnedSkinsByCommanderID :many
SELECT
  commander_id,
  skin_id,
  expires_at
FROM owned_skins
WHERE commander_id = $1
ORDER BY skin_id ASC
`

func (q *Queries) ListOwnedSkinsByCommanderID(ctx context.Context, commanderID int64) ([]OwnedSkin, error) {
	rows, err := q.db.Query(ctx, listOwnedSkinsByCommanderID, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OwnedSkin
	for rows.Next() {
		var i OwnedSkin
		if err := rows.Scan(&i.CommanderID, &i.SkinID, &i.ExpiresAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOwnedSpWeaponsByOwnerID = `-- name: ListOwnedSpWeaponsByOwnerID :many
SELECT
  owner_id,
  id,
  template_id,
  attr_1,
  attr_2,
  attr_temp_1,
  attr_temp_2,
  effect,
  pt,
  equipped_ship_id
FROM owned_spweapons
WHERE owner_id = $1
ORDER BY id ASC
`

func (q *Queries) ListOwnedSpWeaponsByOwnerID(ctx context.Context, ownerID int64) ([]OwnedSpweapon, error) {
	rows, err := q.db.Query(ctx, listOwnedSpWeaponsByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OwnedSpweapon
	for rows.Next() {
		var i OwnedSpweapon
		if err := rows.Scan(
			&i.OwnerID,
			&i.ID,
			&i.TemplateID,
			&i.Attr1,
			&i.Attr2,
			&i.AttrTemp1,
			&i.AttrTemp2,
			&i.Effect,
			&i.Pt,
			&i.EquippedShipID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
