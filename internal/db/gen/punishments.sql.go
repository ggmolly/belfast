// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: punishments.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const deletePunishment = `-- name: DeletePunishment :execresult
DELETE FROM punishments
WHERE id = $1
`

func (q *Queries) DeletePunishment(ctx context.Context, id int64) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deletePunishment, id)
}

const getPunishment = `-- name: GetPunishment :one
SELECT id, punished_id, lift_timestamp, is_permanent
FROM punishments
WHERE id = $1
`

func (q *Queries) GetPunishment(ctx context.Context, id int64) (Punishment, error) {
	row := q.db.QueryRow(ctx, getPunishment, id)
	var i Punishment
	err := row.Scan(
		&i.ID,
		&i.PunishedID,
		&i.LiftTimestamp,
		&i.IsPermanent,
	)
	return i, err
}

const updatePunishment = `-- name: UpdatePunishment :execresult
UPDATE punishments
SET punished_id = $2,
    lift_timestamp = $3,
    is_permanent = $4
WHERE id = $1
`

type UpdatePunishmentParams struct {
	ID            int64
	PunishedID    int64
	LiftTimestamp pgtype.Timestamptz
	IsPermanent   bool
}

func (q *Queries) UpdatePunishment(ctx context.Context, arg UpdatePunishmentParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updatePunishment,
		arg.ID,
		arg.PunishedID,
		arg.LiftTimestamp,
		arg.IsPermanent,
	)
}

const upsertPunishment = `-- name: UpsertPunishment :one

INSERT INTO punishments (
  punished_id,
  lift_timestamp,
  is_permanent
) VALUES (
  $1, $2, $3
)
ON CONFLICT (id)
DO UPDATE SET
  punished_id = EXCLUDED.punished_id,
  lift_timestamp = EXCLUDED.lift_timestamp,
  is_permanent = EXCLUDED.is_permanent
RETURNING id
`

type UpsertPunishmentParams struct {
	PunishedID    int64
	LiftTimestamp pgtype.Timestamptz
	IsPermanent   bool
}

// Punishment queries
func (q *Queries) UpsertPunishment(ctx context.Context, arg UpsertPunishmentParams) (int64, error) {
	row := q.db.QueryRow(ctx, upsertPunishment, arg.PunishedID, arg.LiftTimestamp, arg.IsPermanent)
	var id int64
	err := row.Scan(&id)
	return id, err
}
