// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: commander_living_area_covers.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteCommanderLivingAreaCover = `-- name: DeleteCommanderLivingAreaCover :exec
DELETE FROM commander_living_area_covers
WHERE commander_id = $1
  AND cover_id = $2
`

type DeleteCommanderLivingAreaCoverParams struct {
	CommanderID int64
	CoverID     int64
}

func (q *Queries) DeleteCommanderLivingAreaCover(ctx context.Context, arg DeleteCommanderLivingAreaCoverParams) error {
	_, err := q.db.Exec(ctx, deleteCommanderLivingAreaCover, arg.CommanderID, arg.CoverID)
	return err
}

const getCommanderLivingAreaCover = `-- name: GetCommanderLivingAreaCover :one
SELECT commander_id, cover_id, unlocked_at, is_new
FROM commander_living_area_covers
WHERE commander_id = $1
  AND cover_id = $2
`

type GetCommanderLivingAreaCoverParams struct {
	CommanderID int64
	CoverID     int64
}

func (q *Queries) GetCommanderLivingAreaCover(ctx context.Context, arg GetCommanderLivingAreaCoverParams) (CommanderLivingAreaCover, error) {
	row := q.db.QueryRow(ctx, getCommanderLivingAreaCover, arg.CommanderID, arg.CoverID)
	var i CommanderLivingAreaCover
	err := row.Scan(
		&i.CommanderID,
		&i.CoverID,
		&i.UnlockedAt,
		&i.IsNew,
	)
	return i, err
}

const listCommanderLivingAreaCovers = `-- name: ListCommanderLivingAreaCovers :many

SELECT commander_id, cover_id, unlocked_at, is_new
FROM commander_living_area_covers
WHERE commander_id = $1
ORDER BY cover_id ASC
`

// Commander living area cover queries
func (q *Queries) ListCommanderLivingAreaCovers(ctx context.Context, commanderID int64) ([]CommanderLivingAreaCover, error) {
	rows, err := q.db.Query(ctx, listCommanderLivingAreaCovers, commanderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommanderLivingAreaCover
	for rows.Next() {
		var i CommanderLivingAreaCover
		if err := rows.Scan(
			&i.CommanderID,
			&i.CoverID,
			&i.UnlockedAt,
			&i.IsNew,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommanderLivingAreaCoverIsNew = `-- name: UpdateCommanderLivingAreaCoverIsNew :exec
UPDATE commander_living_area_covers
SET is_new = $3
WHERE commander_id = $1
  AND cover_id = $2
`

type UpdateCommanderLivingAreaCoverIsNewParams struct {
	CommanderID int64
	CoverID     int64
	IsNew       bool
}

func (q *Queries) UpdateCommanderLivingAreaCoverIsNew(ctx context.Context, arg UpdateCommanderLivingAreaCoverIsNewParams) error {
	_, err := q.db.Exec(ctx, updateCommanderLivingAreaCoverIsNew, arg.CommanderID, arg.CoverID, arg.IsNew)
	return err
}

const upsertCommanderLivingAreaCover = `-- name: UpsertCommanderLivingAreaCover :exec
INSERT INTO commander_living_area_covers (
  commander_id,
  cover_id,
  unlocked_at,
  is_new
) VALUES (
  $1, $2, $3, $4
)
ON CONFLICT (commander_id, cover_id)
DO UPDATE SET
  unlocked_at = EXCLUDED.unlocked_at,
  is_new = EXCLUDED.is_new
`

type UpsertCommanderLivingAreaCoverParams struct {
	CommanderID int64
	CoverID     int64
	UnlockedAt  pgtype.Timestamptz
	IsNew       bool
}

func (q *Queries) UpsertCommanderLivingAreaCover(ctx context.Context, arg UpsertCommanderLivingAreaCoverParams) error {
	_, err := q.db.Exec(ctx, upsertCommanderLivingAreaCover,
		arg.CommanderID,
		arg.CoverID,
		arg.UnlockedAt,
		arg.IsNew,
	)
	return err
}
