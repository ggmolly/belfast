// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: user_registration_challenges.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRegistrationChallenge = `-- name: CreateRegistrationChallenge :exec
INSERT INTO user_registration_challenges (
  id,
  commander_id,
  pin,
  password_hash,
  password_algo,
  status,
  expires_at,
  consumed_at,
  created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
`

type CreateRegistrationChallengeParams struct {
	ID           string
	CommanderID  int64
	Pin          string
	PasswordHash string
	PasswordAlgo string
	Status       string
	ExpiresAt    pgtype.Timestamptz
	ConsumedAt   pgtype.Timestamptz
	CreatedAt    pgtype.Timestamptz
}

func (q *Queries) CreateRegistrationChallenge(ctx context.Context, arg CreateRegistrationChallengeParams) error {
	_, err := q.db.Exec(ctx, createRegistrationChallenge,
		arg.ID,
		arg.CommanderID,
		arg.Pin,
		arg.PasswordHash,
		arg.PasswordAlgo,
		arg.Status,
		arg.ExpiresAt,
		arg.ConsumedAt,
		arg.CreatedAt,
	)
	return err
}

const getLatestPendingRegistrationChallengeByCommander = `-- name: GetLatestPendingRegistrationChallengeByCommander :one

SELECT id, commander_id, pin, password_hash, password_algo, status, expires_at, consumed_at, created_at
FROM user_registration_challenges
WHERE commander_id = $1
  AND status = $2
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestPendingRegistrationChallengeByCommanderParams struct {
	CommanderID int64
	Status      string
}

// User registration challenge queries
func (q *Queries) GetLatestPendingRegistrationChallengeByCommander(ctx context.Context, arg GetLatestPendingRegistrationChallengeByCommanderParams) (UserRegistrationChallenge, error) {
	row := q.db.QueryRow(ctx, getLatestPendingRegistrationChallengeByCommander, arg.CommanderID, arg.Status)
	var i UserRegistrationChallenge
	err := row.Scan(
		&i.ID,
		&i.CommanderID,
		&i.Pin,
		&i.PasswordHash,
		&i.PasswordAlgo,
		&i.Status,
		&i.ExpiresAt,
		&i.ConsumedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingRegistrationChallengeByPin = `-- name: GetPendingRegistrationChallengeByPin :one
SELECT id, commander_id, pin, password_hash, password_algo, status, expires_at, consumed_at, created_at
FROM user_registration_challenges
WHERE pin = $1
  AND status = $2
  AND expires_at > $3
LIMIT 1
`

type GetPendingRegistrationChallengeByPinParams struct {
	Pin       string
	Status    string
	ExpiresAt pgtype.Timestamptz
}

func (q *Queries) GetPendingRegistrationChallengeByPin(ctx context.Context, arg GetPendingRegistrationChallengeByPinParams) (UserRegistrationChallenge, error) {
	row := q.db.QueryRow(ctx, getPendingRegistrationChallengeByPin, arg.Pin, arg.Status, arg.ExpiresAt)
	var i UserRegistrationChallenge
	err := row.Scan(
		&i.ID,
		&i.CommanderID,
		&i.Pin,
		&i.PasswordHash,
		&i.PasswordAlgo,
		&i.Status,
		&i.ExpiresAt,
		&i.ConsumedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingRegistrationChallengeByPinForUpdate = `-- name: GetPendingRegistrationChallengeByPinForUpdate :one
SELECT id, commander_id, pin, password_hash, password_algo, status, expires_at, consumed_at, created_at
FROM user_registration_challenges
WHERE pin = $1
  AND status = $2
FOR UPDATE
`

type GetPendingRegistrationChallengeByPinForUpdateParams struct {
	Pin    string
	Status string
}

func (q *Queries) GetPendingRegistrationChallengeByPinForUpdate(ctx context.Context, arg GetPendingRegistrationChallengeByPinForUpdateParams) (UserRegistrationChallenge, error) {
	row := q.db.QueryRow(ctx, getPendingRegistrationChallengeByPinForUpdate, arg.Pin, arg.Status)
	var i UserRegistrationChallenge
	err := row.Scan(
		&i.ID,
		&i.CommanderID,
		&i.Pin,
		&i.PasswordHash,
		&i.PasswordAlgo,
		&i.Status,
		&i.ExpiresAt,
		&i.ConsumedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRegistrationChallengeByID = `-- name: GetRegistrationChallengeByID :one
SELECT id, commander_id, pin, password_hash, password_algo, status, expires_at, consumed_at, created_at
FROM user_registration_challenges
WHERE id = $1
`

func (q *Queries) GetRegistrationChallengeByID(ctx context.Context, id string) (UserRegistrationChallenge, error) {
	row := q.db.QueryRow(ctx, getRegistrationChallengeByID, id)
	var i UserRegistrationChallenge
	err := row.Scan(
		&i.ID,
		&i.CommanderID,
		&i.Pin,
		&i.PasswordHash,
		&i.PasswordAlgo,
		&i.Status,
		&i.ExpiresAt,
		&i.ConsumedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRegistrationChallengeByIDForUpdate = `-- name: GetRegistrationChallengeByIDForUpdate :one
SELECT id, commander_id, pin, password_hash, password_algo, status, expires_at, consumed_at, created_at
FROM user_registration_challenges
WHERE id = $1
FOR UPDATE
`

func (q *Queries) GetRegistrationChallengeByIDForUpdate(ctx context.Context, id string) (UserRegistrationChallenge, error) {
	row := q.db.QueryRow(ctx, getRegistrationChallengeByIDForUpdate, id)
	var i UserRegistrationChallenge
	err := row.Scan(
		&i.ID,
		&i.CommanderID,
		&i.Pin,
		&i.PasswordHash,
		&i.PasswordAlgo,
		&i.Status,
		&i.ExpiresAt,
		&i.ConsumedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateRegistrationChallengeStatus = `-- name: UpdateRegistrationChallengeStatus :exec
UPDATE user_registration_challenges
SET status = $2,
    consumed_at = $3
WHERE id = $1
`

type UpdateRegistrationChallengeStatusParams struct {
	ID         string
	Status     string
	ConsumedAt pgtype.Timestamptz
}

func (q *Queries) UpdateRegistrationChallengeStatus(ctx context.Context, arg UpdateRegistrationChallengeStatusParams) error {
	_, err := q.db.Exec(ctx, updateRegistrationChallengeStatus, arg.ID, arg.Status, arg.ConsumedAt)
	return err
}
